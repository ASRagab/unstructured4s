{"docs":[{"location":"/paradox.json","text":"","title":""},{"location":"/index.html","text":"","title":"Unstructured4s"},{"location":"/index.html#unstructured4s","text":"A Scala 3 library that wraps the Unstructured API.","title":"Unstructured4s"},{"location":"/index.html#setup","text":"The library is published to Sonatype and Maven Central.\nsbt libraryDependencies += \"org.twelvehart\" % \"unstructured4s-core\" % \"0.0.0+7-75cc4e0f-SNAPSHOT\" Maven <dependencies>\n  <dependency>\n    <groupId>org.twelvehart</groupId>\n    <artifactId>unstructured4s-core</artifactId>\n    <version>0.0.0+7-75cc4e0f-SNAPSHOT</version>\n  </dependency>\n</dependencies> Gradle dependencies {\n  implementation \"org.twelvehart:unstructured4s-core:0.0.0+7-75cc4e0f-SNAPSHOT\"\n}\nSee the Unstructured4s Examples for an even quicker start.","title":"Setup"},{"location":"/getting-started.html","text":"","title":"Getting Started"},{"location":"/getting-started.html#getting-started","text":"","title":"Getting Started"},{"location":"/getting-started.html#api-key","text":"You will need to obtain an apikey from Unstructured.io\nBy default, an apikey is needed to make the client; however, individual requests can also be provided a separate apikey, which will override the default, when passed a header, see further below.","title":"Api Key"},{"location":"/getting-started.html#instantiating-the-client","text":"In addition to the unstructured4s-core module, you will need to provide an sttp backend, you can use any of the backends provided by sttp as long as you can provide a client with the effect capability F[_] that has a Functor instance (this will typical require some kind of interoperability module with the cats typeclass hierarchy)\nFirst obtain the necessary dependencies for sttp, here are the ones for ZIO:\nsbt libraryDependencies ++= Seq(\n  \"com.softwaremill.sttp.client3\" % \"async-http-client-backend-zio\" % \"latest\",\n  \"dev.zio\" % \"zio-interop-cats\" % \"latest\"\n) Maven <dependencies>\n  <dependency>\n    <groupId>com.softwaremill.sttp.client3</groupId>\n    <artifactId>async-http-client-backend-zio</artifactId>\n    <version>latest</version>\n  </dependency>\n  <dependency>\n    <groupId>dev.zio</groupId>\n    <artifactId>zio-interop-cats</artifactId>\n    <version>latest</version>\n  </dependency>\n</dependencies> Gradle dependencies {\n  implementation \"com.softwaremill.sttp.client3:async-http-client-backend-zio:latest\"\n  implementation \"dev.zio:zio-interop-cats:latest\"\n}\nHere is the one for the fs2 backend:\nsbt libraryDependencies += \"com.softwaremill.sttp.client3\" % \"async-http-client-backend-fs2\" % \"latest\" Maven <dependencies>\n  <dependency>\n    <groupId>com.softwaremill.sttp.client3</groupId>\n    <artifactId>async-http-client-backend-fs2</artifactId>\n    <version>latest</version>\n  </dependency>\n</dependencies> Gradle dependencies {\n  implementation \"com.softwaremill.sttp.client3:async-http-client-backend-fs2:latest\"\n}\nTo instantiate the client, first include these imports:\nimport org.twelvehart.unstructured4s.*\nimport org.twelvehart.unstructured4s.model.*\nimport sttp.client3.*\nNext, declare the backend and retrieve the apikey from the environment:\nobject BasicApp extends App {\n  private val backend = HttpClientSyncBackend()\n  private val client = Unstructured4s.make(backend, ApiKey(apiKey))\n}\nFor ZIO you will likely be making a ZLayer:\nimport zio.*\nimport zio.interop.catz.*\nimport org.twelvehart.unstructured4s.*\nimport org.twelvehart.unstructured4s.model.*\nimport sttp.client3.asynchttpclient.zio.*\nimport sttp.client3.*\n\nobject ZIOApp extends ZIOAppDefault {\n  private val live = AsyncHttpClientZioBackend.layer()\n\n  def program: ZIO[SttpClient, Throwable, Unit] =\n    for {\n      backend <- ZIO.service[SttpClient]\n      _       <- Unstructured4s.make(backend, ApiKey(apiKey))\n    } yield ()\n}\nFor fs2 you will likely be making a cats.effect.Resource:\nimport cats.effect.*\nimport org.twelvehart.unstructured4s.*\nimport org.twelvehart.unstructured4s.model.*\nimport sttp.capabilities\nimport sttp.capabilities.fs2.Fs2Streams\nimport sttp.client3.SttpBackend\nimport sttp.client3.httpclient.fs2.HttpClientFs2Backend\nimport sttp.client3.logging.slf4j.Slf4jLoggingBackend\n\nobject CatsEffectApp extends IOApp.Simple {\n  private val backendResource: Resource[IO, SttpBackend[IO, Fs2Streams[IO] & capabilities.WebSockets]] =\n    HttpClientFs2Backend\n      .resource[IO]()\n      .map(backend =>\n        // You can even use logged backends as an example\n        Slf4jLoggingBackend(\n          backend,\n          logRequestHeaders = false,\n          logRequestBody = true\n        )\n      )\n\n  override def run: IO[Unit] =\n    backendResource.use { backend =>\n      for {\n        client <- Unstructured4s.make(backend, ApiKey(apiKey))\n      } yield ()\n    }","title":"Instantiating the Client"},{"location":"/making-requests.html","text":"","title":"Making Requests"},{"location":"/making-requests.html#making-requests","text":"The Unstructured.io API takes multipart form requests. There are currently two types of requests one can make with the Unstructured4s client:","title":"Making Requests"},{"location":"/making-requests.html#partition","text":"The partition request is used to send one file to be partitioned by Unstructured.io. The request takes three parameters, only one of which does not have a default value:\nfile - The file to be partitioned, of type UnstructuredFile, just an opaque type for java.io.File request - Unstructured4sRequestFields The request fields to be sent to Unstructured.io. These can be of two types: GeneralRequestFields HiResRequestFields customHeaders - List[Header] - A list of custom sttp headers to be sent with the request. These will override any default headers including the unstructured-api-key header.\nA hopefully sensible default with all necessary parameters for each is provided in api client.\ncopysourcefinal case class GeneralRequestFields(\n    outputFormat: OutputFormat = OutputFormat.Json,\n    xmlKeepTags: Boolean = false,\n    coordinates: Boolean = false,\n    encoding: Encoding = `UTF-8`,\n    skipInferTableTypes: Option[Vector[String]] = None,\n    ocrLanguages: Option[Seq[String]] = None,\n    includePageBreaks: Boolean = false,\n    ocrStrategy: Option[OCRStrategy] = None\n) extends Unstructured4sRequestFields:\ncopysourcefinal case class HiResRequestFields(\n    outputFormat: OutputFormat = OutputFormat.Json,\n    encoding: Encoding = Encoding(\"utf-8\"),\n    coordinates: Boolean = false,\n    pdfInferTableStructure: Boolean = false,\n    skipInferTableTypes: Option[Vector[String]] = None,\n    includePageBreaks: Boolean = false,\n    hiResModelName: Option[HiResModelName] = None,\n    ocrLanguages: Option[Seq[String]] = None\n) extends Unstructured4sRequestFields:\nThen to make the request:\nresponse = client.partition(file) // can provide a request and headers here as well","title":"partition"},{"location":"/making-requests.html#partitionmultiple","text":"The partitionMultiple request is used to send many files to be partitioned by Unstructured.io. It is the same as the partition request except that\nfiles - The files to be partitioned, of type Seq[UnstructuredFile]\nSimilarly:\nresponse = client.partitionMultiple(files) // can provide a request and headers here as well","title":"partitionMultiple"},{"location":"/responses.html","text":"","title":"Responses"},{"location":"/responses.html#responses","text":"Every method on the Unstructured4s client returns an F[Unstructured4sResponse[A]] where F[_] is the effect capability of your chosen backend.\nRequests to Unstructured.io are multipart requests, the return type is always json despite the api allowing text/csv as well. This is likely to change in the future, but the recommended approach is to use the json response type.","title":"Responses"},{"location":"/responses.html#partitionresponse","text":"The PartitionResponse is a case class that represents the response from the Unstructured.io for a single file.\ncopysourcecase class PartitionResponse(`type`: String, elementId: String, metadata: Metadata, text: String)","title":"PartitionResponse"},{"location":"/responses.html#unstructured4sresponse","text":"copysourcecase class Unstructured4sResponse[A](result: Either[Unstructured4sError, List[A]])\nIt wraps an Either[Unstructured4sError, A] where A is either a PartitionResponse or List[PartitionResponse] which depends on whether you called partition or partitionMultiple respectively.","title":"Unstructured4sResponse"},{"location":"/responses.html#unstructured4serror","text":"There exists an implicit conversion between this and ResponseException[String, io.circe.Error] which is error return type from sttp there are two kinds of Unstructured4sErrors\nJsonParsingError - This is returned when the response from the Unstructured.io is not valid json. HttpResponseError - This is returned when the response is not 200 OK.","title":"Unstructured4sError"}]}