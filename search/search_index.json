{"docs":[{"location":"/paradox.json","text":"","title":""},{"location":"/index.html","text":"","title":"Unstructured4s"},{"location":"/index.html#unstructured4s","text":"A Scala 3 library that provides a functional wrapper for the Unstructured API.","title":"Unstructured4s"},{"location":"/index.html#setup","text":"The library is published to Sonatype and Maven Central.\nsbt libraryDependencies += \"org.twelvehart\" %% \"unstructured4s-core\" % \"0.1.6\" Maven <dependencies>\n  <dependency>\n    <groupId>org.twelvehart</groupId>\n    <artifactId>unstructured4s-core_3</artifactId>\n    <version>0.1.6</version>\n  </dependency>\n</dependencies> Gradle dependencies {\n  implementation \"org.twelvehart:unstructured4s-core_3:0.1.6\"\n}\nSee the Unstructured4s examples for an even quicker start.","title":"Setup"},{"location":"/getting-started.html","text":"","title":"Getting Started"},{"location":"/getting-started.html#getting-started","text":"","title":"Getting Started"},{"location":"/getting-started.html#apikey","text":"You will need to obtain an ApiKey from Unstructured\nBy default, an apikey is needed to make the client; however, individual requests can also be provided a separate apikey, which will override the default, when passed a header.","title":"ApiKey"},{"location":"/getting-started.html#instantiating-the-client","text":"In addition to the unstructured4s-core module, you will need to provide an sttp backend, you can use any of the backends provided by sttp as long as you can provide a client with the effect capability F[_] that has a Functor instance (this will typical require some kind of interoperability module with the cats typeclass hierarchy if you arenâ€™t using cats-effect)\nFirst obtain the necessary dependencies for sttp, here are the ones for ZIO:\nsbt libraryDependencies ++= Seq(\n  \"com.softwaremill.sttp.client3\" %% \"async-http-client-backend-zio\" % \"3.9.0\",\n  \"dev.zio\" %% \"zio-interop-cats\" % \"23.0.0.8\"\n) Maven <dependencies>\n  <dependency>\n    <groupId>com.softwaremill.sttp.client3</groupId>\n    <artifactId>async-http-client-backend-zio_3</artifactId>\n    <version>3.9.0</version>\n  </dependency>\n  <dependency>\n    <groupId>dev.zio</groupId>\n    <artifactId>zio-interop-cats_3</artifactId>\n    <version>23.0.0.8</version>\n  </dependency>\n</dependencies> Gradle dependencies {\n  implementation \"com.softwaremill.sttp.client3:async-http-client-backend-zio_3:3.9.0\"\n  implementation \"dev.zio:zio-interop-cats_3:23.0.0.8\"\n}\nHere is the one for the fs2 backend:\nsbt libraryDependencies += \"com.softwaremill.sttp.client3\" %% \"async-http-client-backend-fs2\" % \"3.9.0\" Maven <dependencies>\n  <dependency>\n    <groupId>com.softwaremill.sttp.client3</groupId>\n    <artifactId>async-http-client-backend-fs2_3</artifactId>\n    <version>3.9.0</version>\n  </dependency>\n</dependencies> Gradle dependencies {\n  implementation \"com.softwaremill.sttp.client3:async-http-client-backend-fs2_3:3.9.0\"\n}\nTo instantiate the client, first include these imports:\nimport org.twelvehart.unstructured4s.*\nimport org.twelvehart.unstructured4s.model.*\nimport sttp.client3.*\nNext, declare the backend and retrieve the apikey from the environment:\nobject BasicApp extends App {\n  private val backend = HttpClientSyncBackend()\n  private val client = Unstructured4s.make(backend, ApiKey(apiKey))\n}\nFor ZIO you will likely be making a ZLayer:\nimport zio.*\nimport zio.interop.catz.*\nimport org.twelvehart.unstructured4s.*\nimport org.twelvehart.unstructured4s.model.*\nimport sttp.client3.asynchttpclient.zio.*\nimport sttp.client3.*\n\nobject ZIOApp extends ZIOAppDefault {\n  private val live = AsyncHttpClientZioBackend.layer()\n\n  def program: ZIO[SttpClient, Throwable, Unit] =\n    for {\n      backend <- ZIO.service[SttpClient]\n      apiKey  <- ZIO.fromEither(apiKeyEnv)\n      client  = Unstructured4s.make(backend, ApiKey(apiKey))\n    } yield ()\n}\nFor fs2 you will likely be making a cats.effect.Resource:\nimport cats.effect.*\nimport org.twelvehart.unstructured4s.*\nimport org.twelvehart.unstructured4s.model.*\nimport sttp.capabilities\nimport sttp.capabilities.fs2.Fs2Streams\nimport sttp.client3.SttpBackend\nimport sttp.client3.httpclient.fs2.HttpClientFs2Backend\nimport sttp.client3.logging.slf4j.Slf4jLoggingBackend\n\nobject CatsEffectApp extends IOApp.Simple {\n  private val backendResource: Resource[IO, SttpBackend[IO, Fs2Streams[IO] & capabilities.WebSockets]] =\n    HttpClientFs2Backend\n      .resource[IO]()\n      .map(backend =>\n        // You can even use logged backends as an example\n        Slf4jLoggingBackend(\n          backend,\n          logRequestHeaders = false,\n          logRequestBody = true\n        )\n      )\n\n  override def run: IO[Unit] =\n    backendResource.use { backend =>\n      for {\n        apiKey <- IO.fromEither(apiKeyEnv)\n        client = Unstructured4s.make(backend, ApiKey(apiKey))\n      } yield ()\n    }","title":"Instantiating the Client"},{"location":"/making-requests.html","text":"","title":"Making Requests"},{"location":"/making-requests.html#making-requests","text":"The Unstructured API takes multipart form requests. There are currently two types of requests one can make with the Unstructured4s client:","title":"Making Requests"},{"location":"/making-requests.html#partition","text":"The partition request is used to send one file to be partitioned by Unstructured.io. The request takes three parameters, only one of which does not have a default value:\nfile - The file to be partitioned, of type UnstructuredFile, just an opaque type for java.io.File request - Unstructured4sRequestFields The request fields to be sent to Unstructured.io. These can be of two types: GeneralRequestFields HiResRequestFields customHeaders - List[Header] - A list of custom sttp headers to be sent with the request. These will override any default headers including the unstructured-api-key header.\nA hopefully sensible default with all necessary parameters for each is provided in api client.","title":"partition"},{"location":"/making-requests.html#generalrequestfields","text":"copysourceoutputFormat: OutputFormat = OutputFormat.Json,\nxmlKeepTags: Boolean = false,\ncoordinates: Boolean = false,\nencoding: Encoding = `UTF-8`,\nskipInferTableTypes: Option[Vector[String]] = None,\nocrLanguages: Option[Seq[String]] = None,\nincludePageBreaks: Boolean = false,\nocrStrategy: OCRStrategy = OCRStrategy.Auto","title":"GeneralRequestFields"},{"location":"/making-requests.html#hiresrequestfields","text":"copysourceoutputFormat: OutputFormat = OutputFormat.Json,\nencoding: Encoding = `UTF-8`,\ncoordinates: Boolean = false,\npdfInferTableStructure: Boolean = false,\nskipInferTableTypes: Option[Vector[String]] = None,\nincludePageBreaks: Boolean = false,\nhiResModelName: Option[HiResModelName] = None,\nocrLanguages: Option[Seq[String]] = None\nThen to make the request:\nresponse = client.partition(file) // can provide a request and headers here as well","title":"HiResRequestFields"},{"location":"/making-requests.html#partitionmultiple","text":"The partitionMultiple request is used to send many files to be partitioned by Unstructured.io. It is the same as the partition request except that\nfiles - The files to be partitioned, of type Seq[UnstructuredFile]\nSimilarly:\nresponse = client.partitionMultiple(files) // can provide a request and headers here as well","title":"partitionMultiple"},{"location":"/responses.html","text":"","title":"Responses"},{"location":"/responses.html#responses","text":"Every method on the Unstructured4s client returns an F[Unstructured4sResponse[A]] where F[_] is the effect capability of your chosen backend.\nRequests to Unstructured are multipart requests, the return type is always json despite the api allowing text/csv as well. This is likely to change in the future, but the recommended approach is to use the json response type.","title":"Responses"},{"location":"/responses.html#partitionresponse","text":"The PartitionResponse is a case class that represents the response from the Unstructured for a single file.\ncopysourcecase class PartitionResponse(`type`: String, elementId: String, metadata: Metadata, text: String)","title":"PartitionResponse"},{"location":"/responses.html#unstructured4sresponse","text":"copysourcecase class Unstructured4sResponse[A](result: Either[Unstructured4sError, List[A]])\nIt wraps an Either[Unstructured4sError, A] where A is either a PartitionResponse or List[PartitionResponse] which depends on whether you called partition or partitionMultiple respectively.","title":"Unstructured4sResponse"},{"location":"/responses.html#unstructured4serror","text":"There exists an implicit conversion between this error type and ResponseException[String, io.circe.Error] which is error return type from sttp there are two kinds of Unstructured4sErrors\nJsonParsingError - This is returned when the response from Unstructured is not valid json. HttpResponseError - This is returned when the response is not 200 OK.","title":"Unstructured4sError"}]}